1. C/C++主要有以下五种内存存储区： 
	全局/静态存储区域：存全局变量，静态变量。程序编译时内存已分配好，并存在于程序整个运行期间，程序结束后由系统统一释放 
		全局变量和静态变量被分配到同一块内存中。 
			C 语言中，全局变量又分为初始化的和未初始化的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域。同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放。
			在 C++ 里面没有区分，他们共同占用同一块内存区。
	栈：存放函数的参数值，局部变量，函数执行结束时会被自动释放。栈内存分配运算内置于处理器的指令集中，效率高，但是容量有限。
	堆（动态内存分配）：通过new和malloc由低到高分配，由delete或free手动释放或者程序结束自动释放。动态内存的生存期人为决定，使用灵活。缺点是容易分配/释放不当容易造成内存泄漏，频繁分配/释放会产生大量内存碎片。 若程序员不释放，程序结束时可能由OS（操作系统）回收
	字符/文字常量区： 存放常量字符串，程序结束时由系统释放(最好手动释放)
	程序代码区： 存放函数体的二进制代码

2. 堆：　是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。

3. 栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。每个Ｃ　＋＋对象的数据成员也存在在栈中，每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。


4. 一个函数被同一个线程调用2次以上，得到的结果具有可再现性(多次调用函数，得到的结果是一样的)。那么我们说这个函数是可重入的。
	可重入函数设计方法：
	不在函数内部使用静态或者全局数据
	不返回静态或者全局数据，所有的数据都由函数调用者提供
	使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据
	如果必须访问全局数据，使用互斥锁来保护
	不调用不可重入函数

5. 使用 malloc 分配内存得到的数组指针例如 int * t = (int*)malloc(32); t 可以作为数组的方式使用，可是本质是一个指针，所以使用 sizeof(t) 时得到的只是 int* 类型的长度。而如果使用 int t [8]; 类型得到数组， t 本质是数组名，但也是指向数组开始位置的指针；所以使用 sizeof(t) 得到的是该数组的长度。

6.在堆中使用二级存储方式可以提供堆的整理机制。程序指向不变的一级指针，然后一级指针再指向内存管理中的可变的二级存储空间。
7. 在写 #define 语句包含传入参数时，最好用() 标名运算顺序，不然容易在替换时出错。 for example:
	#define MAX(a,b) ((a)>(b)?(a):(b))
8. assert() 其实是一个宏，其中一个定义为：
	#ifdef	NDEBUG
	# define assert(expr)		(__ASSERT_VOID_CAST (0))
	就是说，如果是在调试阶段，我们需要用到 assert()来中断程序并调试程序，那么就不要定义 NDEBUG 宏，让 assert() 处于可用状态。而如果是程序在正式使用阶段，应该定义 NDEBUG 宏，让在正式运行阶段即使数据出问题了，也不能崩溃程序。
	所以在脚本文件中设置 debug 系统时，也要有类似的做法，就是用一个宏定义 debug 等级，在调试时可以让普通错误都中断程序，而在实际运行阶段，只有不可能的操作才会中断程序。
9. 在标准库中的函数，无论在调用文件中是否包含声明该函数的 .h 文件，调用文件在链接时，都会把该函数包含进来。
	在遇到没有声明的函数时，编译器(gcc) 会根据调用的方法例如 malloc(40) 推断函数原型为 int malloc (int );然后匹配标准库(或者一起编译的文件)中是否有相同原型的函数，如果有就会调用。如果没有相同原型，就会报错。头文件所做的，就是告诉编译器，我有怎样类型的函数原型。所以，最好还是把相关的声明写好并包含好。
10. segmentation fault,bus errors; 
	1. 对指针的解引用错误。
11.在编写 C 程序时，经常需要通过函数参数回传数据。一般的 API 的参数就会要求传递一个变量的地址，然后该 API 函数就会根据地址找到该变量，该变量作为可以存放数据的空间，用来把数据写入。例如：
	int pthread_join(pthread_t thread,void **rval_ptr);
	函数等待一个线程返回，并把需要返回的一个指针 (void *) 放入到 rval_ptr 指针指向的空间中。这里 **rval_ptr 的意思就是我希望你能通过一个 (void **) 类型的值，给我一个 (void *) 类型的指针变量的空间，然后我返回时，会把一个(void *) 类型的指针通过 (void**) 指针，写入到 (void *) 变量空间中。所以一般调用时
		pthread_t id;
		void *ptr;
		pthread_join(id,&ptr);
	那么，ptr 就是返回的 (void *) 值了。
	如果 
		pthread_t id;
		void **ptr;
		pthread_join(id,ptr);
	这样调用看上去是没问题的，可是实际上，我没有地方写我想返回的 (void *) 指针了。
12. c 里面的数组名称，函数名称，都是该对象的指针，如果需要传指针，不需要取地址运算符