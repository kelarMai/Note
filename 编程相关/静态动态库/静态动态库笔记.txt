1.编译过程： 扫描、语法分析、语义分析、源代码分析、代码生成和目标代码优化。
	1.1 可使用lex工具设定规则进行词法扫描；产生记号；
	1.2 采用上下文无关语法的分析方法，生成以表达式为节点的语法树；yacc工具
	1.3 分析静态语义，包括声明和类型的匹配，类型的转换。
	1.4 编译器前端可以对源码进行优化；然后转换为中间代码（三地址码、P代码等）
	1.5 编译器后端生成目标代码和目标代码优化。
2.链接主要包括：地址和空间分配（Address and Storage Allocation）、符号决议(Symbol Resolution)、重定位(Relocation)；
3.运行时库：支持程序运行的基本函数的集合。库是一组目标文件的包，是常用代码编译成目标文件后打包存放。
4.从结构上来说，编译后的文件是可执行文件格式，只是还没有经过链接的过程；其中部分的符号和地址可能还没调整。
5.目标文件（中间文件）一般为Windows的.obj 和 Linux 的.o;动态链接库(.dll;.so)；静态链接库(.lib;.a);文件都是按照可执行文件(.exe;.ELF)格式存储的。
6.静态链接库是把多个目标文件捆绑在一起系形成一个问价，再加上索引。
7.COFF文件主要是包含“段”的机制，不同目标文件可以拥有不同数量及类型的“段”，还定义了调试数据格式。
8.目标文件包含：机器指令代码、数据；链接时的信息（符号表、调试信息、字符串），按不同信息以段存储。
	8.1 机器指令一般放在代码段(Code Section：.code .text)中，全局变量、局部静态变量放在数据段(Data Section : .data); .bss段存放未初始化的全局变量（不同编译器有所不同，静态static全局变量则确定放置在此）、局部静态变量；
9.可以在ELF文件中插入自定义段名和存放数据并调用（使用objcopy工具插入；怎么调用？）；一个文件可以有多个相同段名文件。
10.ELF文件头，包含短表（Section Header Table）
11.目标文件之间相互拼接换实际上是目标文件之间对地址的引用；即对函数和变量的地址的引用。
12.函数签名： 包含函数信息： 函数名、参数类型、所在的类和名称空间等。
13.使用extern "C" 方法在C++中对C的库和函数进行调用。
14.强符号和弱符号；强引用和弱引用。
15.一般目标程序中包含调试信息；信息占用比较大的内存空间；在软件发布时，可以把这些信息去掉以节省空间；linux 使用 strip 命令；
16.链接的一般使用相似段合并的方法，经过空间和地址分配、符号解析与重定位把目标文件合并。
17.在目标文件中，有一个重定位表，保存需要重定位的符号的位置，即重定位入口。
18.一种语言的开发环境往往会附带有语言库，就是对操作系统的API的包装；
19.一般静态库就是一组目标文件的压缩集合；在linux中可以使用ar 命令对多个目标文件进行压缩并进行编号和索引；
20.典型动态装载方法：覆盖装入(Overlay)，页映射(Paging)
21.链接视图中，可执行文件的不同模块放置在相应的位置中，比如.data,.bss,.text;而执行视图中，一般根据不同模块的可执行情况，比如只读、可写可读等分配模块。






100.configure 检查程序编译时以来的环境和对程序编译安装进行配置。
	pkg-config 检索系统中安装库文件的信息；库的编译和链接。
	环境变量PKG_CONFIG_PATH是用来设置.pc文件的搜索路径的
101 工具使用
	101.1: objdump -s 可以将段的内容16进制打印出来；-d 可以将指令段反汇编；
	101.2：readelf 查看ELF详细信息；-s ;
	101.3 size可以查看ELF文件大小信息 
	101.4 nm 查看文件额的符号信息
	101.5 ld 可以把文件连接起来
	101.6 ar 查.a 库中包含的目标文件；
