1.编译过程： 扫描、语法分析、语义分析、源代码分析、代码生成和目标代码优化。
	1.1 可使用lex工具设定规则进行词法扫描；产生记号；
	1.2 采用上下文无关语法的分析方法，生成以表达式为节点的语法树；yacc工具
	1.3 分析静态语义，包括声明和类型的匹配，类型的转换。
	1.4 编译器前端可以对源码进行优化；然后转换为中间代码（三地址码、P代码等）
	1.5 编译器后端生成目标代码和目标代码优化。
2.链接主要包括：地址和空间分配（Address and Storage Allocation）、符号决议(Symbol Resolution)、重定位(Relocation)；
3.运行时库：支持程序运行的基本函数的集合。库是一组目标文件的包，是常用代码编译成目标文件后打包存放。
4.从结构上来说，编译后的文件是可执行文件格式，只是还没有经过链接的过程；其中部分的符号和地址可能还没调整。
	链接器把符号和地址进行重定位修正；在进行重定位前，这些需要被修正得地方称为重定位入口。
5.目标文件（中间文件）一般为Windows的.obj 和 Linux 的.o;动态链接库(.dll;.so)；静态链接库(.lib;.a);文件都是按照可执行文件(.exe;.ELF)格式存储的。
6.静态链接库是把多个目标文件捆绑在一起形成一个文件，再加上索引。
7.COFF文件主要是包含“段”的机制，不同目标文件可以拥有不同数量及类型的“段”，还定义了调试数据格式。
8.目标文件包含：机器指令代码、数据；链接时的信息（符号表、调试信息、字符串），按不同信息以段存储。
	8.1 机器指令一般放在代码段(Code Section：.code .text)中，全局变量、局部静态变量放在数据段(Data Section : .data); .bss段存放未初始化的全局变量（不同编译器有所不同，静态static全局变量则确定放置在此）、局部静态变量；
	8.2 程序被装载后，数据和指令是分别被映射到两个虚拟内存区域的。并且数据区域是可读写的，指令区域是只读的。
9.可以在ELF文件中插入自定义段名和存放数据并调用（使用objcopy工具插入；怎么调用？）；一个文件可以有多个相同段名文件。
10.ELF文件头，包含短表（Section Header Table）
11.目标文件之间相互拼接换实际上是目标文件之间对地址的引用；即对函数和变量的地址的引用。
	每个目标文件都有一个相应的符号表(Symbol Table)
12.函数签名(变量名修饰)： 包含函数信息： 函数名、参数类型、所在的类和名称空间等。
13.使用extern "C" 方法在C++中对C的库和函数进行调用。否则直接调用时，因为编译器对 c++ 和 c 的符号名的修饰方法不同，导致 c++ 中对 c 的函数/变量的调用会出错。
	C++ 中使用宏 "__cplusplus" 来确定当前的编译单元为 c++ ；然后编译时就确保是使用  c++  的修饰方法。
14.强符号和弱符号；强引用和弱引用。
15.编译时加上 "-g" 参数，编译器就会在产生的目标文件里面加上调试信息
	信息占用比较大的内存空间；在软件发布时，可以把这些信息去掉以节省空间；linux 使用 strip 命令；
	另：经测试，即使不加 -g 参数，产生的目标文件也会加上部分的调试信息（或者其他信息），使用 strip 命令后会变小很多。
16.链接一般使用相似段合并的方法，经过空间和地址分配、符号解析与重定位把目标文件合并。
	ld -e main ：把 main 函数作为程序入口， ld 链接器默认的程序入口为 _start
	ELF 可执行文件默认从地址 0x08048000 开始分配（32位，旧版本）
17.在目标文件中，有一个重定位表，保存需要重定位的符号的位置，即重定位入口。
17.1 函数级别的链接
17.2 不同编译器编译的目标函数经常是无法链接的，特别是 c++ 的文件。
18.一种语言的开发环境往往会附带有语言库，就是对操作系统的API的包装；
19.一般静态库就是一组目标文件的压缩集合；在linux中可以使用 ar 命令对多个目标文件进行压缩并进行编号和索引；
	这些目标文件是已经链接完成的，还是尚未进行链接的？
	如果程序需要链接这个静态库的部分目标文件，是会把需要的目标文件解压出来，然后仅链接该部分。
20.典型动态装载方法：覆盖装入(Overlay)，页映射(Paging)；都是利用程序的局部性原理。
21.链接视图中，可执行文件的不同模块放置在相应的位置中，比如.data,.bss,.text;而执行视图中，一般根据不同模块的可执行情况，比如只读、可写可读等分配模块。
22.创建虚拟页空间并不是创建空间，而是拆功能键映射函数所需要的相应的数据结构，把虚拟空间的地址映射到相应的物理空间中。

22. 查看 gcc 和 g++ 的链接查找地址
	`gcc -print-prog-name=cc1plus` -v
	`g++ -print-prog-name=cc1plus` -v
23. centos 查看动态链接库路径
	默认路径：LD_LIBRARY_PATH
	可以编译时添加路径；[参考](https://blog.csdn.net/zxh2075/article/details/54629318)
24. 动态链接涉及运行时的链接及多个文件的装载，必须要有操作系统的支持。
25. Linux 系统采用 SO-NAME 机制，把共享库的文件名去掉次版本号和发布版本号，只保留主版本号，使程序在动态链接时能链接到所需版本的动态链接库。
26. 编译输出 ELF 文件时，将被依赖的共享库的 SO-NAME 保存到 ".dynamic" 中，这样，当动态链接器进行共享库依赖文件查找时，就会根据系统中各种共享库目录中的 SO-NAME 软链接自动定向到最新版本的共享库。


100.configure 检查程序编译时以来的环境和对程序编译安装进行配置。
	pkg-config 检索系统中安装库文件的信息；库的编译和链接。
	环境变量PKG_CONFIG_PATH是用来设置.pc文件的搜索路径的
101 工具使用
	101.1: objdump -s 可以将段的内容16进制打印出来；-d 可以将指令段反汇编；
	101.2：readelf 查看ELF详细信息；-s ;
	101.3 size可以查看ELF文件大小信息 
	101.4 nm 查看文件额的符号信息
	101.5 ld 可以把文件连接起来
	101.6 ar 查.a 库中包含的目标文件；

问：
1. 链接器是如何根据头文件找到需要的动态（静态）链接库的？每个函数遍历一遍所有库？不可能吧。还是说有某个程序把所有库的函数制作成全局共享函数表，然后在链接时直接查询该表？
	应该是有一个类似于 ldconfig 这样的程序做全局共享函数/变量表这样的事情的。

